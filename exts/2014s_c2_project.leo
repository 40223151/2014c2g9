<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://leoeditor.com/leo_toc.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="2014pythonE.20140224205837.3150" a="E"><vh>@settings</vh>
<v t="2014pythonE.20140224205837.3151"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="2014pythonE.20140224205837.3152"><vh>@string initial_split_orientation = horizontal</vh></v>
<v t="2014pythonE.20140331085053.2405"><vh>@string rst3_write_intermediate_extension = .rst</vh></v>
</v>
<v t="2014python.20140224210642.3165" a="E"><vh>c2_w1</vh>
<v t="2014python.20140224210642.3168"><vh>程式說明</vh></v>
<v t="public_kmol.20140302202325.1714"><vh>break, continue and pass</vh></v>
<v t="public_kmol.20140302202325.1717"><vh>Leo editor 的檔案指令</vh></v>
<v t="2014pythonE.20140331085053.2401" a="E"><vh>@path w1</vh>
<v t="2014python.20140224210642.3167"><vh>@shadow c2_w1_python1.py</vh></v>
</v>
</v>
<v t="public_kmol.20140302202325.1715" a="E"><vh>c2_w2</vh>
<v t="public_kmol.20140302202325.1716"><vh>程式說明</vh></v>
<v t="2014python.20140306154142.1723"><vh>CherryPy 程式架構</vh></v>
<v t="2014python.20140306154142.1724"><vh>git 程式到 OpehShift</vh></v>
<v t="2014python.20140306154142.1725"><vh>Html 超文件表單與 CherryPy 程式</vh></v>
<v t="2014pythonE.20140401100126.1860" a="E"><vh>@path w2</vh>
<v t="2014python.20140306154142.1722"><vh>@auto c2_w2.py</vh></v>
<v t="2014pythonE.20140403094306.2148" a="E"><vh>@path static</vh>
<v t="2014pythonE.20140403094306.2149"><vh>@edit axuploader.js</vh></v>
</v>
</v>
</v>
<v t="2014pythonE.20140402100203.1908" a="E"><vh>c2_w7</vh>
<v t="2014pythonE.20140402100203.1914" a="E"><vh>利用 pandoc 進行格式轉換</vh>
<v t="2014pythonE.20140402100203.1915"><vh>@button pandoc</vh></v>
<v t="2014pythonE.20140402100203.1916" a="E"><vh>@path c2wp/pandoc</vh>
<v t="2014pythonE.20140402100203.1917"><vh>@edit demo.txt</vh></v>
</v>
</v>
</v>
<v t="2014pythonE.20140414091257.1680" a="E"><vh>c2_w8</vh>
<v t="2014pythonE.20140418222946.1967"><vh>說明</vh></v>
<v t="2014pythonE.20140418222946.1968"><vh>同步設定</vh></v>
<v t="2014pythonE.20140414091257.1916"><vh>簡單分頁</vh>
<v t="2014pythonE.20140414091257.1917"><vh>另一個例子</vh></v>
</v>
<v t="2014pythonE.20140414091257.1681" a="E"><vh>@path wsgi</vh>
<v t="course-mde-tw.20140417093332.2216" a="E"
expanded="course-mde-tw.20140417093332.2218,"><vh>@file application</vh></v>
</v>
</v>
<v t="2014spring.20140502183555.1776"><vh>c2_w10 - w18</vh></v>
<v t="2014spring.20140503095553.1876" a="E"><vh>c2_w11</vh>
<v t="2014spring.20140503095553.1927" a="E"><vh>分組程式開發</vh>
<v t="2014spring.20140503095553.1928" a="E"><vh>@path wsgi/programs/c2g1</vh>
<v t="2014spring.20140503095553.1929"><vh>@edit __init__.py</vh></v>
</v>
<v t="2014spring.20140503095553.1932" a="E"><vh>@path wsgi/programs/c2g2</vh>
<v t="2014spring.20140503095553.1933"><vh>@edit __init__.py</vh></v>
</v>
</v>
<v t="2014spring.20140503095553.1883" a="E"><vh>利用 pandoc 進行格式轉換</vh>
<v t="2014spring.20140503095553.1884"><vh>注意事項</vh></v>
<v t="2014spring.20140503095553.1886"><vh>@button pandoc_auto</vh></v>
<v t="2014spring.20140503095553.1887" a="E"><vh>@path wsgi/doc</vh>
<v t="2014spring.20140503095553.1888"><vh>@edit title.txt</vh></v>
</v>
</v>
<v t="2014spring.20140503095553.1908" a="E"><vh>分組協同報告區</vh>
<v t="2014spring.20140503095553.1909" a="E"><vh>@path wsgi/doc</vh>
<v t="2014spring.20140503095553.1910" a="E"><vh>@path c2g1</vh>
<v t="2014spring.20140503095553.1911"><vh>@edit doc.txt</vh></v>
</v>
<v t="2014spring.20140503095553.1912" a="E"><vh>@path c2g2</vh>
<v t="2014spring.20140503095553.1913"><vh>@edit doc.txt</vh></v>
</v>
</v>
</v>
</v>
<v t="2014spring.20140502183555.1864"><vh>c2_w12 任務</vh></v>
</vnodes>
<tnodes>
<t tx="2014python.20140224210642.3165"></t>
<t tx="2014python.20140224210642.3168">第一週程式練習題目:

從 1 累加到 50, 總數是多少?

寫一個讓使用者可以輸入上面累加題目的開始整數與終止整數, 並且印出累加後的總數值, 先寫成單機程式.

讓上一程式可以判斷使用者輸入非整數或前大後小的異常狀況, 並且在任何輸入情況下, 都有合適的程式回應.

在上一個程式的毎一行都加上說明註解, 並且在一開始程式執行時, 就說明程式的使用方法, 使用者必須注意要項, 最後再讓使用者執行程式, 並且列出程式運算結果.</t>
<t tx="2014python.20140306154142.1723">1. 導入所需模組

2. 設定近端與遠端目錄

3. 建立主物件

4. 安排啟動設定

5. 在近端或遠端啟動程式</t>
<t tx="2014python.20140306154142.1724">所需的可攜 git 程式檔案

指令搜尋路徑設定

遠端的 public key 與近端的 private key

近端的特殊目錄設定

git 相關指令

OpenShift 與 Bitbucket 倉儲資料同步指令</t>
<t tx="2014python.20140306154142.1725">表單超文件

CherryPy 程式處理 keyword arguments 與 positional arguments

Keyword Arguments

Any page handler that is called by CherryPy (index, or any other suitable method) can receive 
additional data from HTML or other forms using keyword arguments. For example, the following 
login form sends the username and the password as form arguments using the POST method:
    
    &lt;form action="doLogin" method="post"&gt;
    &lt;p&gt;Username&lt;/p&gt;
    &lt;input type="text" name="username" value=""
        size="15" maxlength="40"/&gt;
    &lt;p&gt;Password&lt;/p&gt;
    &lt;input type="password" name="password" value=""
        size="10" maxlength="40"/&gt;
    &lt;p&gt;&lt;input type="submit" value="Login"/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type="reset" value="Clear"/&gt;&lt;/p&gt;
&lt;/form&gt;

The following code can be used to handle this URL:

class Root(object):
    def doLogin(self, username=None, password=None):
        """Check the username &amp; password"""
    doLogin.exposed = True
    
Both arguments have to be declared as keyword arguments. The default value can be used either to provide a 
suitable default value for optional arguments, or to provide means for the application to detect if some values 
were missing from the request.

CherryPy supports both the GET and POST method for HTML forms. Arguments are passed the same way, 
regardless of the original method used by the browser to send data to the web server.

Positional Arguments

When a request is processed, the URI is split into its components, and each one is matched in order against 
the nodes in the tree. Any trailing components are “virtual path” components and are passed as positional 
arguments. For example, the URI "/branch/leaf/4" might result in the call: app.root.branch.leaf(4), or 
app.root.index(branch, leaf, 4) depending on how you have your handlers arranged.

Partial matches can happen when a URL contains components that do not map to the object tree. This can happen 
for a number of reasons. For example, it may be an error; the user just typed the wrong URL. But it also can mean 
that the URL contains extra arguments.

For example, assume that you have a blog-like application written in CherryPy that takes the year, 
month and day as part of the URL http://localhost/blog/2005/01/17. This URL can be handled by the following code:

class Root(object):
    def blog(self, year, month, day):
        """Deliver the blog post. According to *year* *month* *day*.
        """
    blog.exposed = True

root = Root()

So the URL above will be mapped as a call to:

root.blog('2005', '01', '17')

In this case, there is a partial match up to the blog component. The rest of the URL cannot be found in the 
mounted object tree. In this case, the blog() method will be called, and the positional parameters will receive 
the remaining path segments as arguments. The values are passed as strings; in the above mentioned example, the arguments would still need to be converted back into numbers, but the idea is correctly presented.

Default methods

If the default dispatcher is not able to locate a suitable page handler by walking down the tree, it has a last-ditch option: it starts walking back up the tree looking for default methods. Default methods work just like any other method with positional arguments, but are defined one level further down, in case you have multiple methods to expose. For example, we could have written the above “blog” example equivalently with a “default” method instead:

class Blog(object):
    def default(self, year, month, day):
        """This method catch the positional arguments
         *year*,*month*,*day* to delivery the blog content.
        """
    default.exposed = True


class Root(object):
    pass

root = Root()
root.blog = Blog()
So the URL http://localhost/blog/2005/01/17 will be mapped as a call to:

root.blog.default('2005', '01', '17')

You could achieve the same effect by defining a __call__ method in this case, but “default” just reads better. ;)

Special characters

You can use dots in a URI like /path/to/my.html, but Python method names do not allow dots. To work around this, 
the default dispatcher converts all dots in the URI to underscores before trying to find the page handler. In the example, 
therefore, you would name your page handler “def my_html”. However, this means the page is also available at the 
URI /path/to/my_html. If you need to protect the resource (e.g. with authentication), you must protect both URLs.

New in version 3.2: The default dispatcher now takes a ‘translate’ argument, which converts all characters 
in string.punctuation to underscores using the builtin str.translate method of string objects. You are free to 
specify any other translation string of length 256.

Other Dispatchers

But Mr. Fielding mentions two kinds of “mapping implementations” above: trees and hash tables (‘dicts’ in Python). 
Some web developers claim trees are difficult to change as an application evolves, and prefer to use dicts (or a list of tuples) 
instead. Under these schemes, the mapping key is often a regular expression, and the value is the handler function. For example:

def root_index(name):
    return "Hello, %s!" % name

def branch_leaf(size):
    return str(int(size) + 3)

mappings = [
    (r'^/([^/]+)$', root_index),
    (r'^/branch/leaf/(\d+)$', branch_leaf),
    ]
CherryPy allows you to use a Dispatcher other than the default if you wish. By using another Dispatcher 
(or writing your own), you gain complete control over the arrangement and behavior of your page handlers 
(and config). To use another dispatcher, set the request.dispatch config entry to the dispatcher you like:

d = cherrypy.dispatch.RoutesDispatcher()
d.connect(name='hounslow', route='hounslow', controller=City('Hounslow'))
d.connect(name='surbiton', route='surbiton', controller=City('Surbiton'),
          action='index', conditions=dict(method=['GET']))
d.mapper.connect('surbiton', controller='surbiton',
                 action='update', conditions=dict(method=['POST']))

conf = {'/': {'request.dispatch': d}}
cherrypy.tree.mount(root=None, config=conf)
A couple of notes about the example above:

Since Routes has no controller hierarchy, there’s nothing to pass as a root to cherrypy.tree.mount; pass None in this case.
Usually you’ll use the same dispatcher for an entire app, so specifying it at the root (“/”) is common. 
But you can use different dispatchers for different paths if you like.
Because the dispatcher is so critical to finding handlers (and their ancestors), this is one of the few cases where you 
cannot use _cp_config; it’s a chicken-and-egg problem: you can’t ask a handler you haven’t found yet how it wants to be found.
Since Routes are explicit, there’s no need to set the exposed attribute. All routes are always exposed.
CherryPy ships with additional Dispatchers in cherrypy._cpdispatch.

PageHandler Objects
Because the Dispatcher sets cherrypy.request.handler, it can also control the input and output of that handler 
function by wrapping the actual handler. The default Dispatcher passes “virtual path” components as 
positional arguments and passes query-string and entity (GET and POST) parameters as keyword arguments. 
It uses a PageHandler object for this, which looks a lot like:

class PageHandler(object):
    """Callable which sets response.body."""

    def __init__(self, callable, *args, **kwargs):
        self.callable = callable
        self.args = args
        self.kwargs = kwargs

    def __call__(self):
        return self.callable(*self.args, **self.kwargs)
The actual default PageHandler is a little bit more complicated (because the args and kwargs are bound later), 
but you get the idea. And you can see how easy it would be to provide your own behavior, whether your own 
inputs or your own way of modifying the output. Remember, whatever is returned from the handler will be 
bound to cherrypy.response.body and will be used as the response entity.

Replacing page handlers
The handler that’s going to be called during a request is available at cherrypy.request.handler, which means 
your code has a chance to replace it before the handler runs. It’s a snap to write a Tool to do so with a HandlerWrapperTool:

to_skip = (KeyboardInterrupt, SystemException, cherrypy.HTTPRedirect)
def PgSQLWrapper(next_handler, *args, **kwargs):
    trans.begin()
    try:
        result = next_handler(*args, **kwargs)
        trans.commit()
    except Exception, e:
        if not isinstance(e, to_skip):
            trans.rollback()
        raise
    trans.end()
    return result

cherrypy.tools.pgsql = cherrypy._cptools.HandlerWrapperTool(PgSQLWrapper)
Configuration
The default arrangement of CherryPy handlers is a tree. This enables a very powerful configuration technique: 
config can be attached to a node in the tree and cascade down to all children of that node. Since the mapping of URI’s 
to handlers is not always 1:1, this provides a flexibility which is not as easily definable in other, flatter arrangements.

However, because the arrangement of config is directly related to the arrangement of handlers, it is the 
responsibility of the Dispatcher to collect per-handler config, merge it with per-URI and global config, and bind the 
resulting dict to cherrypy.request.config. This dict is of depth 1 and will contain all config entries which are in effect for the current request.</t>
<t tx="2014pythonE.20140224205837.3150"></t>
<t tx="2014pythonE.20140224205837.3151">QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 22px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 22px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 22px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 22px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 22px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 22px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="2014pythonE.20140224205837.3152">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="2014pythonE.20140331085053.2401"></t>
<t tx="2014pythonE.20140331085053.2405"></t>
<t tx="2014pythonE.20140401100126.1860"></t>
<t tx="2014pythonE.20140402100203.1908"></t>
<t tx="2014pythonE.20140402100203.1914">@language latex

% 中文內容設定

\usepackage{xeCJK}    % 中英文字行分開設置
\usepackage[T1]{fontspec}    %設定字體用
\usepackage{graphicx}
\usepackage{fancyvrb} % for frame on Verbatim
% 新細明體
% 文鼎ＰＬ新宋
\setCJKmainfont{新細明體}</t>
<t tx="2014pythonE.20140402100203.1915">@language python
import os
'''
c is the commander of the outline containing the script.
g is Leo's leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
d = c.scanAllDirectives(p)
#g.es(d)
# d 為 commander 由目前所在目錄進行指令設定掃描
# d 資料格式為 dictionary
''' 
實際操作下, d 為 
{'tabwidth': -4, 'lineending': None, 'language': 'python', 'encoding': None, 'pluginsList': [], 'pagewidth': 70, 'wrap': True, 'path': 'D:\\github\\mdeCourse\\2013spring', 'delims': ('#', '', '')}
'''
# 假如是在協同模式下, 可以利用 Python 程式結合其他組員上傳的 .txt 檔案, 組成 demo.txt 之後再處理成 html 或 pdf
'''
在處理 pandoc 之前,  將協同人員上傳的 file1.txt 與 file2.txt 結合為 demo.txt

filenames = ['file1.txt', 'file2.txt']
directory = "V:/2014c2/w2/local_data/downloads/"
with open('V:/2014c2/c2wp/pandoc/demo.txt', 'w', encoding="utf-8") as outfile:
    for fname in filenames:
        fname = directory+fname
        with open(fname, encoding="utf-8") as infile:
            for line in infile:
                outfile.write(line)
            outfile.write("\n")
'''
# 將目錄指到 pandoc
mandir = d.get('path') + "/c2wp/pandoc"
g.es(mandir)
os.chdir(mandir)
# 先轉一份 html 
os.system("V:\\apps\\pandoc\\pandoc.exe -s demo.txt -o demo.html")
# 利用 pandoc 將 demo.txt 轉為 demo.tex, 在此決定是否要有 toc
os.system("V:\\apps\\pandoc\\pandoc.exe -s demo.txt --toc -o demo.tex")
# 中文設定必須要放在 begin document 之前
setup = ''' 
\\usepackage{xeCJK}    % 中英文字行分開設置 
\\usepackage[T1]{fontspec}    %設定字體用 
\\usepackage{graphicx} 
\\usepackage{fancyvrb} % for frame on Verbatim 
\\setCJKmainfont{新細明體}
'''
# 在 demo.tex 最前頭加上"中文設定"
file = open("demo.tex", "r", encoding="utf-8")
lines = file.read().splitlines()
file.close()
file = open("demo.tex", "w", encoding="utf-8")
for i in range(len(lines)):
    # 設法將中文設定放在文件開始之前, 以便蓋掉之前的設定
    if "\\begin{document}" in lines[i]:
        file.write(setup+lines[i]+"\n")
    else:
        file.write(lines[i]+"\n")
file.close()
target_name = "demo"
filename = target_name+".tex"
os.system("V:\\apps\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
os.system("V:\\apps\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
filename = target_name+".xdv"
os.system("V:\\apps\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xdvipdfmx.exe -vv -E "+filename)

filename = target_name+".pdf"
os.system(filename)</t>
<t tx="2014pythonE.20140402100203.1916"></t>
<t tx="2014pythonE.20140403094306.2148"></t>
<t tx="2014pythonE.20140414091257.1680"></t>
<t tx="2014pythonE.20140414091257.1681"></t>
<t tx="2014pythonE.20140414091257.1916"># 可以利用 python pagination 或 paginate 找到更多參考資料

# -*- coding: utf-8 -*-

class PageResult(list):

    def __init__(self, total=0, page_no=1, page_size=0, edge_size=0):
        self.total = total
        self.page_size = page_size if page_size &gt; 0 else 0
        self.edge_size = edge_size if edge_size &gt; 0 else 0

        if page_no &lt;= 0:
            self.no = 1
        elif self.max &gt;=1 and page_no &gt; self.max:
            self.no = self.max
        else:
            self.no = page_no

    @property
    def start(self):
        return (self.no - 1) * self.page_size

    @property
    def max(self):
        if self.page_size &gt; 0:
            return (self.total + self.page_size - 1) / self.page_size
        else: #不分页，显示全部条目
            return 1

    @property
    def has_prev(self):
        return self.no &gt; 1

    @property
    def has_next(self):
        return self.no &lt; self.max

    @property
    def slider(self):
        if self.edge_size &gt; 0:
            start = max(self.no - self.edge_size, 1)
            stop = min(self.no + self.edge_size, self.max)
        else: #不滑窗，显示全部页码
            start, stop = 1, self.max
        return range(start, stop + 1)

    def clear(self):
        del self[:]

    def page_dict(self):
        page = {"curr_page":self.no, "data_count":self.total, "page_count":self.max}
        page["has_prev"], page["has_next"] = self.has_prev, self.has_next
        page["page_range"] = self.slider
        return page


class Pagination(object):

    def __init__(self, query):
        self.query = query

    def all(self, offset=0, limit=0):
        if limit == 0:
            return self.query.all()
        else:
            return self.query.offset(offset).limit(limit).all() #SQLAlchemy orm
            return self.query.all()[offset : offset + limit] #Django orm

    def count(self):
        return self.query.count()

    def head(self):
        return self.query.first()

    def paginate(self, page_no=1, page_size=0, edge_size=0):
        result = PageResult(self.count(), page_no, page_size, edge_size)
        result.extend( self.all(result.start, result.page_size) )
        return result
</t>
<t tx="2014pythonE.20140414091257.1917">Simple Pagination

By Armin Ronacher filed in Application Structure

Unless you are using JavaScript to dynamically load more contents pagination is a neat concept to structure many items of information into multiple pages. The idea is that if you have 100 items you show 20 per page and have 5 pages in total then.

Simple Pagination Class

If you are using Flask-SQLAlchemy you can use the integrated pagination class it provides. Here is a simple pagination class that does roughly the same without the support for slicing SQLAlchemy query objects:

from math import ceil


class Pagination(object):

    def __init__(self, page, per_page, total_count):
        self.page = page
        self.per_page = per_page
        self.total_count = total_count

    @property
    def pages(self):
        return int(ceil(self.total_count / float(self.per_page)))

    @property
    def has_prev(self):
        return self.page &gt; 1

    @property
    def has_next(self):
        return self.page &lt; self.pages

    def iter_pages(self, left_edge=2, left_current=2,
                   right_current=5, right_edge=2):
        last = 0
        for num in xrange(1, self.pages + 1):
            if num &lt;= left_edge or \
               (num &gt; self.page - left_current - 1 and \
                num &lt; self.page + right_current) or \
               num &gt; self.pages - right_edge:
                if last + 1 != num:
                    yield None
                yield num
                last = num
                
URLs and Views

So how do you declare URLs and views when using Pagination? The Werkzeug routing system which Flask use supports this nicely with route level defaults. You specify a “default” for page 1 for the bare URL and provide an integer wildcard for other pages:

from flask import redirect

PER_PAGE = 20

@app.route('/users/', defaults={'page': 1})
@app.route('/users/page/&lt;int:page&gt;')
def show_users(page):
    count = count_all_users()
    users = get_users_for_page(page, PER_PAGE, count)
    if not users and page != 1:
        abort(404)
    pagination = Pagination(page, PER_PAGE, count)
    return render_template('users.html',
        pagination=pagination,
        users=users
    )
    
Note how this code is returning an 404 error for all pages besides the first page if no items were there to display. This is generally a good idea.

When a user heads to /users/page/1 Flask will redirect him automatically to /users/ to keep the URL unique.

URL Generation Helper

Now how can a template generate a URL to a different page without much hassle? Because the only difference from one URL to the other is the page part in it we can provide a little helper function that wraps url_for to generate a new URL to the same endpoint with a different page:

def url_for_other_page(page):
    args = request.view_args.copy()
    args['page'] = page
    return url_for(request.endpoint, **args)
app.jinja_env.globals['url_for_other_page'] = url_for_other_page
Rendering The Pagination
So how do you render such a pagination? Here is a simple macro that uses the iter_pages method of the pagination class to show a simple pagination:

{% macro render_pagination(pagination) %}
  &lt;div class=pagination&gt;
  {%- for page in pagination.iter_pages() %}
    {% if page %}
      {% if page != pagination.page %}
        &lt;a href="{{ url_for_other_page(page) }}"&gt;{{ page }}&lt;/a&gt;
      {% else %}
        &lt;strong&gt;{{ page }}&lt;/strong&gt;
      {% endif %}
    {% else %}
      &lt;span class=ellipsis&gt;…&lt;/span&gt;
    {% endif %}
  {%- endfor %}
  {% if pagination.has_next %}
    &lt;a href="{{ url_for_other_page(pagination.page + 1)
      }}"&gt;Next &amp;raquo;&lt;/a&gt;
  {% endif %}
  &lt;/div&gt;
{% endmacro %}

This snippet by Armin Ronacher can be used freely for anything you like. Consider it public domain.

Comments
Thanks for the code by Sigma0 on 2011-03-15 @ 13:28

It works well. There is a small typo in the following line however:

return int(ceil(self.total / float(self.per_page)))
should be:

return int(ceil(self.total_count / float(self.per_page)))

Comment by Armin Ronacher on 2011-06-08 @ 10:25

Fixed. Thanks :)

small typo by Christian Ştefănescu on 2011-06-08 @ 10:35

In the 'URLs and Views' section, there's a small typo: Pagiation(... instead of Pagination(...

Comment by Wieland Hoffmann on 2011-10-18 @ 20:20
The macro is missing::

{% if pagination.has_prev %}&lt; &lt;a href="{{ url_for_other_page(pagination.page - 1) }}"&gt;&amp;laquo; Previous&lt;/a&gt;&lt; {% endif %}&lt;

Query string by Geoffroy on 2013-10-07 @ 09:30

The url_for_other_page function is not handling query strings in the URL. Just change the line : args = request.view_args.copy() to args = dict(request.view_args.items() + request.args.to_dict().items()) and it works fine.

Comment by hilfi alkaff on 2014-01-29 @ 18:50

Somehow my request.view_args is empty when I have previous search results on the paginated data. I had to use request.args.copy() instead.</t>
<t tx="2014pythonE.20140418222946.1967">已經與 ssh://53513f805004466e55000158@c2-mdec2project.rhcloud.com/~/git/c2.git/ 同步

採用 mdec2project@gmail.com 登記 OpenShift 帳號

Bitbucket 同步倉儲則為: https://bitbucket.org/coursemde/2014c2

由於 Bitbucket 中的資料已經運作 8 週, 並且在第 9 週將 CherryPy 程式碼與 Openshift 同步, 設定步驟:

1. 使用 mde2project@gmail.com 在 Openshift 登記一個帳號.

2. 建立 Python 3.3 應用程式之前, 先將 w8 目錄複製一份命名為 wsgi, 主要在讓程式碼符合 Openshift 的 Python 3.3 程式格式要求, 並且建立能夠安裝 CherryPy 模組的 setup.py.

3. 建立 OpenShift 上的 Python 3.3 應用程式時, 將 Bitbucket 倉儲設為原始碼來源, 此時建立應用程式後, 應該就能執行.

4. 在 local c2project 目錄下, 以 git pull 將 OpenShift 上的應用程式拉回近端, 以便取得 OpenShift 上的應用程式對應資料.

5. 在 local c2project 下, 以 git remote add c2openshift ssh://53513f805004466e55000158@c2-mdec2project.rhcloud.com/~/git/c2.git/ 指定 OpenShift 應用程式為遠端同步倉儲

6. 之後程式更新後, git push origin 將會送到 Bitbucket, git push c2openshift 則會送到 OpenShift</t>
<t tx="2014pythonE.20140418222946.1968">備註
利用 mdec2project At gmail.com 登記 OpenShift mdec2project name space

2014c2 專案: https://bitbucket.org/coursemde/2014c2

與 http://c2-mdec2project.rhcloud.com/ 網站同步

利用 coursemdetw At gmail.com 登記 OpenShift coursemdetw name space

cd project on Bitbucket: https://bitbucket.org/coursemde/2014cd

與 Bitbucket 同步的 OpenShift 網站: http://cdproject-coursemdetw.rhcloud.com/</t>
<t tx="2014spring.20140502183555.1776">評量規劃:

每週以組為單位執行分組任務, 評分類別如下:

每完成一項任務: 得分 5 分

幾乎完成: 得分 4 分

部分完成: 得分 3 分

未能完成: 得分 0 分

Week 12: 二項任務, 配分 10 分

Week 13: 三項任務, 配分 15 分

Week 14: 三項任務, 配分 15 分

Week 15: 三項任務, 配分 15 分

Week 16: 三項任務, 配分 15 分

Week 17: 三項任務, 配分 15 分

Week 18: 三項任務, 配分 15 分

備註: 

各週任務評量將在下課前 15 鐘完成

若該週因放假不上課, 則任務仍由 Github 專案上發送, 並以 take-home 模式執行.</t>
<t tx="2014spring.20140502183555.1864">任務一:

請各組根據 drawlines 方法中的畫直線程式, 在 canvas 正中央以藍色線畫一個半徑 200 的五芒星圖形

任務二:

請設法將五芒星中間填入藍色</t>
<t tx="2014spring.20140503095553.1876">自本週開始將搭協同產品設計實習的便車, 讓全班在 Github 上執行協同程式編寫.

下半學期則將採用 Brython 模式, 以 canvas 網際繪圖模式來練習 Python 3 程式語法.

各組在執行分組任務時必須注意:
    
    1. Python 版次必須使用 3.3 版
    
    2. Leo Editor 必須使用 4.11 版
    
    3. 建立 pdf 與 html 文件則需要 pandoc 與 portableLatex 可攜應用程式(位於 apps 目錄下)
    
    4. Git 則使用可攜版本(位於 apps 目錄下)

各組 push 資料確認事項

    1. git config –list 中的 user.name 是否為各組代號 (代號錯誤將無法取分)
    
    2. application 網站是否可以正確執行
    
    3. .leo 檔案是否可以被 Leo Editor 正確開啟
    
    4. 專案是否可以正確產生協同報告 pdf 與 html 檔案
    
    5. 與 .leo 專案對應的外部目錄與檔案是否正確設定
</t>
<t tx="2014spring.20140503095553.1883">@language latex

% 中文內容設定

\usepackage{xeCJK}    % 中英文字行分開設置
\usepackage[T1]{fontspec}    %設定字體用
\usepackage{graphicx}
\usepackage{fancyvrb} % for frame on Verbatim
% 新細明體
% 文鼎ＰＬ新宋
\setCJKmainfont{新細明體}</t>
<t tx="2014spring.20140503095553.1884">mathspec.sty 檔案必須放在 pandoc 目錄中, 與文書處理原始檔案放在一起.

有關 pandoc 文件編寫手冊

http://johnmacfarlane.net/pandoc/demo/example9/pandocs-markdown.html</t>
<t tx="2014spring.20140503095553.1886">@language python
import os
import re

def atoi(text):
    return int(text) if text.isdigit() else text

def natural_keys(text):
    '''
    alist.sort(key=natural_keys) sorts in human order
    http://nedbatchelder.com/blog/200712/human_sorting.html
    (See Toothy's implementation in the comments)
    '''
    return [ atoi(c) for c in re.split('(\d+)', text) ]
'''
c is the commander of the outline containing the script.
g is Leo's leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
d = c.scanAllDirectives(p)
#g.es(d)
# d 為 commander 由目前所在目錄進行指令設定掃描
# d 資料格式為 dictionary
''' 
實際操作下, d 為 
{'tabwidth': -4, 'lineending': None, 'language': 'python', 'encoding': None, 'pluginsList': [], 'pagewidth': 70, 'wrap': True, 'path': 'D:\\github\\mdeCourse\\2013spring', 'delims': ('#', '', '')}
'''
# 在處理 pandoc 之前,  將協同人員上傳的 file1.txt 與 file2.txt 結合為 demo.txt
# 以下採用 os.walk 自動進入目錄取出目錄與檔案名稱後, 採自然排序
# 最後再利用 insert 將標題頁面放入數列最前頭
'''
# 這裡是原先使用的手動檔名排序數列, 好處為可以任意編排次序
filenames = ['title.txt', 'c2g1/doc.txt', 'c2g2/doc.txt]
'''
# 定義要合併檔案的共同目錄
directory = "V:/project/2014c2/wsgi/doc/"
# 定義一個空數列
filenames = []
for (path, dirs, files) in os.walk(directory):
    for fname in files:
        # 利用 if 判斷式將外部的 title.txt 與其他檔案隔開不取
        if path != directory:
            filenames.append(path+"/"+fname)
# 依照 natural_keys 客製化排序, 使用上面的函式定義
filenames.sort(key=natural_keys)
# 利用 insert 以 0 為索引, 將 title.txt 放在數列最前頭
filenames.insert(0, directory+"title.txt")
# 以下將依據 filenames 數列中的檔案合併為 result.txt 之後再進行文書處理轉換
with open('V:/project/2014c2/wsgi/pandoc/result.txt', 'w', encoding="utf-8") as outfile:
    for fname in filenames:
        #fname = directory+fname
        with open(fname, encoding="utf-8") as infile:
            for line in infile:
                outfile.write(line)
            outfile.write("\n\n")

# 將目錄指到 pandoc
mandir = d.get('path') + "/wsgi/pandoc"
g.es(mandir)
os.chdir(mandir)
# 先轉一份 html 
os.system("V:\\apps\\pandoc\\pandoc.exe -s result.txt -o result.html")
# 利用 pandoc 將 demo.txt 轉為 demo.tex, 在此決定是否要有 toc
os.system("V:\\apps\\pandoc\\pandoc.exe -s result.txt --toc -o result.tex")
# 中文設定必須要放在 begin document 之前
setup = ''' 
\\usepackage{xeCJK}    % 中英文字行分開設置 
\\usepackage[T1]{fontspec}    %設定字體用 
\\usepackage{graphicx} 
\\usepackage{fancyvrb} % for frame on Verbatim 
\\setCJKmainfont{新細明體}
'''
# 在 demo.tex 最前頭加上"中文設定"
file = open("result.tex", "r", encoding="utf-8")
lines = file.read().splitlines()
file.close()
file = open("result.tex", "w", encoding="utf-8")
for i in range(len(lines)):
    # 設法將中文設定放在文件開始之前, 以便蓋掉之前的設定
    if "\\begin{document}" in lines[i]:
        file.write(setup+lines[i]+"\n")
    else:
        file.write(lines[i]+"\n")
file.close()
target_name = "result"
filename = target_name+".tex"
os.system("V:\\apps\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
os.system("V:\\apps\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
filename = target_name+".xdv"
os.system("V:\\apps\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xdvipdfmx.exe -vv -E "+filename)

filename = target_name+".pdf"
os.system(filename)</t>
<t tx="2014spring.20140503095553.1887"></t>
<t tx="2014spring.20140503095553.1908">各組的報告統一放在 doc 目錄下, 並且按照分組編號作為目錄名稱

最後希望能夠利用程式整合各分組報告內容, 統一處理成為 pdf 與 html 檔案

目錄架構:

doc 
    c2g1
        doc.txt
    c2g2
        doc.txt
        
必須整合管理的資料內容:

</t>
<t tx="2014spring.20140503095553.1909"></t>
<t tx="2014spring.20140503095553.1910"></t>
<t tx="2014spring.20140503095553.1912"></t>
<t tx="2014spring.20140503095553.1927">各分組在 Github 中要有一個參與 2014c2 協同程式開發的帳號外

各組員同時在 Github 與 Bitbucket 下都要有對應帳號, 並且利用 Github (不限協同人員個數, 但是免費帳號只允許建立開放專案)或 Bitbucket (專案可以選擇公開或私用, 但是免費帳號只允許最多 5 人協同) 的協同模式, 在小分組下共享程式碼.

Github 2014c2 全班協同專案將會有一個對應的 OpenShift 網站, 各組另外要建立一個分組的 OpenShift 網站與 Github 全班協同專案同步, 以練習各分組的雲端程式部署與控管流程 (各分組成員必須將各自的 public keys 放到分組 OpenShift 應用程式中, 並且自行練習以協同模式控管雲端網站, 而且要與各分組的 Bitbucket 或 Github 程式同步).

各分組雲端程式位於 wsgi/programs/c2g1 目錄下, 使用時必須:
    
    1. 確認主要程式 application 中已經導入分組模組, 且與 root 下屬方法加以對應
    
    也就是下列程式的置入.
    
#####################################################
# 這是 c2g1 組的物件案例定義
#####################################################
# 導入 application 目錄下的模組
# 導入 programs/c2g1 並且命名為 c2g1
# 模組內建使用 __init__.py 中的 C2G1 類別
# 若使用 programs/c2g1/class1.py, 則使用 import programs.c2g1.class1 as c2g1
import programs.c2g1 as c2g1
# 利用 c2g1 目錄下的 __init__.py 檔案中的 C2G1 類別建立案例物件
# 而且指到 application 根目錄下的 c2g1
root.c2g1 = c2g1.C2G1()
#####################################################
# 結束 c2g1 組的物件案例定義
#####################################################

    2. 各分組則在 wsgi/programs/c2gX 目錄下各自開發 __init__.py 程式方法
    
    3. 完成後先在近端測試, 完全符合需求且根據標準流程, 拉下目前協同專案區最新的 github 程式碼後, 檢驗 .leo 是否可以正確開啟, 各對應目錄是否正確配置, application 是否可以正確執行後, 再推送到協同專案區, 並與各分組的 OpenShift 雲端網站進行同步.</t>
<t tx="2014spring.20140503095553.1928"></t>
<t tx="2014spring.20140503095553.1932"></t>
<t tx="public_kmol.20140302202325.1714">break

The break statement in Python terminates the current loop and resumes execution at the next statement, just like the traditional break found in C.

The most common use for break is when some external condition is triggered requiring a hasty exit from a loop. The break statement can be used in both while and for loops.

continue

The continue statement in Python returns the control to the beginning of the while loop. 

The continue statement rejects all the remaining statements in the current iteration of the loop and moves the control back to the top of the loop.

pass

The pass statement in Python is used when a statement is required syntactically but you do not want any command or code to execute.

The pass statement is a null operation; nothing happens when it executes. The pass is also useful in places where your code will eventually go, but has not been written yet (e.g., in stubs for example):
    
http://www.thefreedictionary.com/syntactically</t>
<t tx="public_kmol.20140302202325.1715"></t>
<t tx="public_kmol.20140302202325.1716">第二週程式練習題目:

從 1 累加到 50, 總數是多少? 請將程式寫在 OpenShift 平台上, 採用 URL 輸入變數的模式編寫.

請用表單 Post 的模式改寫上一程式, 並依照2014S C2 Week1的各練習題目, 改寫此一程式.

請同時將 OpenShift 平台上的程式碼, 以 git remote 的方式, 送一份程式碼與相關說明檔案到 Bitbucket 平台上.

參考資料: http://cherrypy.readthedocs.org/en/latest/tutorial/index.html</t>
<t tx="public_kmol.20140302202325.1717">http://leoeditor.com/directives.html

</t>
</tnodes>
</leo_file>
